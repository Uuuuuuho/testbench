---- tOn Matches (93 in 8 files) ----
BasicGtmTom.c (src\...\snsact):37
    Ifx_TimerValue    tOn[2];  /**< \brief PwmHl onTime value */
#elif BOARD == SHIELD_BUDDY
    Ifx_TimerValue    tOn[3];  /**< \brief PwmHl onTime value */
#endif
    struct
BasicGtmTom.c (src\...\snsact):335
		g_GtmTomPwmHl.tOn[0] = g_GtmTomPwmHl.pwmPeriod /2;
		g_GtmTomPwmHl.tOn[1] = g_GtmTomPwmHl.pwmPeriod /2;
    }
#elif BOARD == SHIELD_BUDDY
BasicGtmTom.c (src\...\snsact):342
		g_GtmTomPwmHl.tOn[0] = g_GtmTomPwmHl.pwmPeriod /2;
		g_GtmTomPwmHl.tOn[1] = g_GtmTomPwmHl.pwmPeriod /2;
		g_GtmTomPwmHl.tOn[2] = g_GtmTomPwmHl.pwmPeriod /2;
    }
#endif
BasicGtmTom.c (src\...\snsact):381
    g_GtmTomPwmHl.tOn[0] =  halfPeriod + halfPeriod * IR_Motor.Motor0Vol;
    g_GtmTomPwmHl.tOn[1] =  halfPeriod - halfPeriod * IR_Motor.Motor0Vol;
#elif BOARD == SHIELD_BUDDY
    IR_Motor.Motor0VolU = IR_Motor.Motor0Vol;
BasicGtmTom.c (src\...\snsact):387
    g_GtmTomPwmHl.tOn[0] =  halfPeriod + halfPeriod * IR_Motor.Motor0VolU;
    g_GtmTomPwmHl.tOn[1] =  halfPeriod + halfPeriod * IR_Motor.Motor0VolV;
    //g_GtmTomPwmHl.tOn[2] =  halfPeriod + halfPeriod * IR_Motor.Motor0VolW;
#endif

BasicGtmTom.c (src\...\snsact):395
	IfxGtm_Tom_PwmHl_setOnTime(pwmHl, g_GtmTomPwmHl.tOn);
	IfxGtm_Tom_Timer_applyUpdate(timer);

IfxCcu6_PwmHl.c (src\...\pwmhl):72
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxCcu6_PwmHl_updateCenterAligned(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Updates the x output duty cycle in edge aligned modes (left and right aligned)
IfxCcu6_PwmHl.c (src\...\pwmhl):79
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxCcu6_PwmHl_updateEdgeAligned(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Set the outputs to inactive
IfxCcu6_PwmHl.c (src\...\pwmhl):86
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxCcu6_PwmHl_updateOff(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn);

/** \} */
IfxCcu6_PwmHl.c (src\...\pwmhl):115
    Ifx_TimerValue            tOn[3] = {0, 0, 0};
    IfxCcu6_PwmHl_setOnTime(driver, tOn); /* FIXME move to IfxCcu6_PwmHl_updateOff() */

    /** - All TOP and BOTTOM channel (COUTx) states equals CC6xST */
IfxCcu6_PwmHl.c (src\...\pwmhl):254
    Ifx_TimerValue tOn[IFXCCU6_PWMHL_MAX_CHANNELS] = {0};
    IfxCcu6_PwmHl_updateOff(driver, tOn); /* tOn do not need defined values */

    mcmouts.U         = module->MCMOUTS.U;
IfxCcu6_PwmHl.c (src\...\pwmhl):341
void IfxCcu6_PwmHl_setOnTime(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn)
{
    // Period = 12
IfxCcu6_PwmHl.c (src\...\pwmhl):369
        Ifx_TimerValue tOnX = tOn[i];

        if (tOnX < driver->base.minPulse)
IfxCcu6_PwmHl.c (src\...\pwmhl):482
IFX_STATIC void IfxCcu6_PwmHl_updateCenterAligned(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn)
{
    IfxCcu6_PwmHl_setOnTime(driver, tOn);
}

IfxCcu6_PwmHl.c (src\...\pwmhl):488
IFX_STATIC void IfxCcu6_PwmHl_updateEdgeAligned(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn)
{
    IfxCcu6_PwmHl_setOnTime(driver, tOn);
}

IfxCcu6_PwmHl.c (src\...\pwmhl):494
IFX_STATIC void IfxCcu6_PwmHl_updateOff(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn)
{
    /* Nothing to do */
IfxCcu6_PwmHl.h (src\...\pwmhl):69
typedef void                 (*IfxCcu6_PwmHl_Update)(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn);

/******************************************************************************/
IfxCcu6_PwmHl.h (src\...\pwmhl):242
 * \param tOn ON time
 * \return None
 *
IfxCcu6_PwmHl.h (src\...\pwmhl):248
IFX_EXTERN void IfxCcu6_PwmHl_setOnTime(IfxCcu6_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Set channels which are generating PWM or in "stuck-at" state.
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):52
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):56
IFX_STATIC void IfxGtm_Atom_PwmHl_updateAndShiftOff(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \brief Updates the x output duty cycle in center aligned and center aligned inverted modes
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):60
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Atom_PwmHl_updateCenterAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Updates the x output duty cycle in edge aligned modes (left and right aligned)
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):67
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Atom_PwmHl_updateEdgeAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Set the outputs to inactive
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):74
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Atom_PwmHl_updateOff(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Update Pulse
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):81
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):85
IFX_STATIC void IfxGtm_Atom_PwmHl_updatePulse(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Set Pulse to OFF
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):89
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):93
IFX_STATIC void IfxGtm_Atom_PwmHl_updatePulseOff(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Update Shift Center Aligned
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):97
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):101
IFX_STATIC void IfxGtm_Atom_PwmHl_updateShiftCenterAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \} */
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):219
    Ifx_TimerValue tOn[IFXGTM_ATOM_PWMHL_MAX_NUM_CHANNELS] = {0};
    IfxGtm_Atom_PwmHl_updateOff(driver, tOn); /* tOn do not need defined values */

    /* Transfer the shadow registers */
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):340
void IfxGtm_Atom_PwmHl_setOnTime(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    driver->update(driver, tOn);
}

IfxGtm_Atom_PwmHl.c (src\...\pwmhl):346
void IfxGtm_Atom_PwmHl_setOnTimeAndShift(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    driver->updateAndShift(driver, tOn, shift);
}

IfxGtm_Atom_PwmHl.c (src\...\pwmhl):352
void IfxGtm_Atom_PwmHl_setPulse(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    driver->updatePulse(driver, tOn, offset);
}

IfxGtm_Atom_PwmHl.c (src\...\pwmhl):389
IFX_STATIC void IfxGtm_Atom_PwmHl_updateAndShiftOff(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    IfxGtm_Atom_PwmHl_updateOff(driver, NULL_PTR);
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):395
IFX_STATIC void IfxGtm_Atom_PwmHl_updateCenterAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):407
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):455
IFX_STATIC void IfxGtm_Atom_PwmHl_updateEdgeAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):467
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):515
IFX_STATIC void IfxGtm_Atom_PwmHl_updateOff(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):530
IFX_STATIC void IfxGtm_Atom_PwmHl_updatePulse(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    uint8          channelIndex;
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):544
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex]);
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex]);

IfxGtm_Atom_PwmHl.c (src\...\pwmhl):593
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex + driver->base.channelCount]);
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex + driver->base.channelCount]);

IfxGtm_Atom_PwmHl.c (src\...\pwmhl):637
IFX_STATIC void IfxGtm_Atom_PwmHl_updatePulseOff(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    IfxGtm_Atom_PwmHl_updateOff(driver, NULL_PTR);
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):643
IFX_STATIC void IfxGtm_Atom_PwmHl_updateShiftCenterAligned(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    uint8          channelIndex;
IfxGtm_Atom_PwmHl.c (src\...\pwmhl):656
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):97
typedef void                     (*IfxGtm_Atom_PwmHl_Update)(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

typedef void                     (*IfxGtm_Atom_PwmHl_UpdateShift)(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

typedef void                     (*IfxGtm_Atom_PwmHl_UpdatePulse)(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset);

/******************************************************************************/
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):247
 * \param tOn ON time
 * \return None
 */
IFX_EXTERN void IfxGtm_Atom_PwmHl_setOnTime(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Sets the ON time and Shift
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):254
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):258
IFX_EXTERN void IfxGtm_Atom_PwmHl_setOnTimeAndShift(IfxGtm_Atom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \brief Sets the ON time and offset, all switched are independent
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):262
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Atom_PwmHl.h (src\...\pwmhl):266
IFX_EXTERN void IfxGtm_Atom_PwmHl_setPulse(IfxGtm_Atom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Set up channels
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):52
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):56
IFX_STATIC void IfxGtm_Tom_PwmHl_updateAndShiftOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \brief Updates the x output duty cycle in center aligned and center aligned inverted modes
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):60
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Tom_PwmHl_updateCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Updates the x output duty cycle in edge aligned modes (left and right aligned)
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):67
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Tom_PwmHl_updateEdgeAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Set the outputs to inactive
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):74
 * \param tOn T on
 * \return None
 */
IFX_STATIC void IfxGtm_Tom_PwmHl_updateOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Update Pulse
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):81
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):85
IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Set Pulse to OFF
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):89
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):93
IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulseOff(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Update Shift Center Aligned
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):97
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):101
IFX_STATIC void IfxGtm_Tom_PwmHl_updateShiftCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \} */
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):249
    Ifx_TimerValue tOn[IFXGTM_TOM_PWMHL_MAX_NUM_CHANNELS] = {0};
    IfxGtm_Tom_PwmHl_updateOff(driver, tOn);     /* tOn do not need defined values */

    /* Transfer the shadow registers */
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):369
void IfxGtm_Tom_PwmHl_setOnTime(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    driver->update(driver, tOn);
}

IfxGtm_Tom_PwmHl.c (src\...\pwmhl):375
void IfxGtm_Tom_PwmHl_setOnTimeAndShift(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    driver->updateAndShift(driver, tOn, shift);
}

IfxGtm_Tom_PwmHl.c (src\...\pwmhl):381
void IfxGtm_Tom_PwmHl_setPulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    driver->updatePulse(driver, tOn, offset);
}

IfxGtm_Tom_PwmHl.c (src\...\pwmhl):418
IFX_STATIC void IfxGtm_Tom_PwmHl_updateAndShiftOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):424
IFX_STATIC void IfxGtm_Tom_PwmHl_updateCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):436
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):484
IFX_STATIC void IfxGtm_Tom_PwmHl_updateEdgeAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):496
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):544
IFX_STATIC void IfxGtm_Tom_PwmHl_updateOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
    uint8          channelIndex;
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):560
IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    uint8          channelIndex;
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):574
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex]);
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex]);

IfxGtm_Tom_PwmHl.c (src\...\pwmhl):623
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex + driver->base.channelCount]);
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex + driver->base.channelCount]);

IfxGtm_Tom_PwmHl.c (src\...\pwmhl):667
IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulseOff(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):673
IFX_STATIC void IfxGtm_Tom_PwmHl_updateShiftCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    uint8          channelIndex;
IfxGtm_Tom_PwmHl.c (src\...\pwmhl):686
        x = tOn[channelIndex];

        if (driver->base.inverted != FALSE)
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):137
typedef void                    (*IfxGtm_Tom_PwmHl_Update)(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn);

typedef void                    (*IfxGtm_Tom_PwmHl_UpdateShift)(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

typedef void                    (*IfxGtm_Tom_PwmHl_UpdatePulse)(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset);

/******************************************************************************/
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):289
 * \param tOn ON time
 * \return None
 */
IFX_EXTERN void IfxGtm_Tom_PwmHl_setOnTime(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn);

/** \brief Sets the ON time and Shift
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):296
 * \param tOn ON time
 * \param shift Shift value in ticks
 * \return None
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):300
IFX_EXTERN void IfxGtm_Tom_PwmHl_setOnTimeAndShift(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \brief Sets the ON time and offset, all switched are independent
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):304
 * \param tOn ON times. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Offset value in ticks. Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return None
IfxGtm_Tom_PwmHl.h (src\...\pwmhl):308
IFX_EXTERN void IfxGtm_Tom_PwmHl_setPulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset);

/** \brief Set up channels
IfxStdIf_PwmHl.h (src\...\stdif):113
 * \param tOn Pointer to an array of ON times in ticks. The array size must be equal to the number of PWM channels
 * \return none
 */
typedef void (*IfxStdIf_PwmHl_SetOnTime)(IfxStdIf_InterfaceDriver stdIf, Ifx_TimerValue *tOn);

/** \brief Set the pwm ON time and shift value
IfxStdIf_PwmHl.h (src\...\stdif):120
 * \param tOn Pointer to an array of ON times in ticks. The array size must be equal to the number of PWM channels
 * \param shift Pointer to an array of shift values in ticks. The array size must be equal to the number of PWM channels
 * \return none
IfxStdIf_PwmHl.h (src\...\stdif):124
typedef void (*IfxStdIf_PwmHl_SetOnTimeAndShift)(IfxStdIf_InterfaceDriver stdIf, Ifx_TimerValue *tOn, Ifx_TimerValue *shift);

/** \brief Set the pwm pulse of all switched independently
IfxStdIf_PwmHl.h (src\...\stdif):128
 * \param tOn Pointer to an array of ON times in s. The array size must be equal to the number of PWM channels times 2. Parameters order is  Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \param offset Pointer to an array of offset values in s. The array size must be equal to the number of PWM channels times 2. Parameters order is  Phase 0 top, phase 1 top, ... phase 0 bottom, phase 1 botteom, ...
 * \return none
IfxStdIf_PwmHl.h (src\...\stdif):132
typedef void (*IfxStdIf_PwmHl_SetPulse)(IfxStdIf_InterfaceDriver stdIf, float32 *tOn, float32 *offset);

/** \brief Set channels which are generating PWM or in "stuck-at" state.
IfxStdIf_PwmHl.h (src\...\stdif):250
IFX_INLINE void IfxStdIf_PwmHl_setOnTime(IfxStdIf_PwmHl *stdIf, Ifx_TimerValue *tOn)
{
    stdIf->setOnTime(stdIf->driver, tOn);
}

IfxStdIf_PwmHl.h (src\...\stdif):259
IFX_INLINE void IfxStdIf_PwmHl_setOnTimeAndShift(IfxStdIf_PwmHl *stdIf, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
    stdIf->setOnTimeAndShift(stdIf->driver, tOn, shift);
}

IfxStdIf_PwmHl.h (src\...\stdif):268
IFX_INLINE void IfxStdIf_PwmHl_setPulse(IfxStdIf_PwmHl *stdIf, float32 *tOn, float32 *offset)
{
    stdIf->setPulse(stdIf->driver, tOn, offset);
}

